Source: [Don't use rand(): a guide to random number generators in C++](https://codeforces.com/blog/entry/61587)

## Problem with rand()

**Seed**: A seed in pseudorandom number generation is the initial value used to start the sequence of "random" numbers.

The rand() function returns an integer between 0 and RAND_MAX.
RAND_MAX is a constant defined in <cstdlib> and is typically 32767 (the maximum value for a 16-bit signed integer).
The sequence of numbers generated by rand() depends on the seed value.

The seed can be set using the srand() function.

If you don't set a seed, rand() will use a default seed (usually 1), producing the same sequence of numbers every time the program runs. 

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

int main() {
    srand(time(0));  //Seeds the pseudo-random number generator used by std::rand() with the value seed.

    int lower_bound = 10;
    int upper_bound = 20;

    // Generate a random number between 10 and 20
    int random_number = lower_bound + (rand() % (upper_bound - lower_bound + 1));
    std::cout << "Random number between 10 and 20: " << random_number << std::endl;

    return 0;
}
```
It doesn't stop there though; random_shuffle() also uses rand().

## Solution - Mersenne Twister

It has a very long period of 
`2^19937 âˆ’ 1`, which means it can generate a huge number of random values before repeating the sequence.

`std::mt19937`
This is a specific implementation of the Mersenne Twister algorithm in C++.
It generates 32-bit unsigned integers (uint32_t).


 `std::uniform_int_distribution`
Generates random integers within a specified range [a,b] Each integer in the range has an equal probability of being generated.

```cpp
#include <iostream>
#include <random>

using namespace std;

inline int64_t random_long(long long l = LLONG_MIN,long long r = LLONG_MAX){
    uniform_int_distribution<int64_t> dist(l,r);   
    return dist(rng);
}

int main() {
    random_device rd;  // Seed generator, Hardware entropy source
    mt19937 gen(rd()); // Mersenne Twister engine, seeded with true random value

    //for 64bit integer
    //we should use a much more high-precision clock than time(0)
    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());   
    
    //shuffle(all(a), rng)

    // Define a uniform integer distribution between 1 and 100
    uniform_int_distribution<int> dist(1, 100);     //name can be anything other than dist

    // Generate a random number
    uint32_t raw_random = gen();   //raw output, should be uniform

    int random_number = dist(gen);
    long long rand_ll = random_long();

    cout << "Random number: " << random_number << endl;

    return 0;
}
```

- `uniform_int_distribution` cannot work without a random number engine. The random number engine (e.g., `mt19937`) is essential because it provides the source of randomness, while the distribution (e.g., `uniform_int_distribution`) shapes that randomness into the desired range and statistical properties.

- You could technically use `% mod` but it will add **modulo bias** and does not guarantee uniformity unless `rng` range is perfectly divisible by `mod`.

- The distribution (e.g., `uniform_int_distribution`) does not generate random numbers on its own. Instead, it transforms the raw numbers from the engine into the desired range and distribution.

- If you want to generated Uniform Random Numbers in range `[0, UINT_MAX]`
You could technically use the raw output of `std::mt19937` (a 32-bit generator) since its range is also the same. While `mt19937` is designed to be uniform, `uniform_int_distribution` adds an extra layer of correctness.


```cpp
// DON'T do this - creates same sequence every time
std::mt19937 gen(time(nullptr));  // Only changes once per second
```


| Feature                     | `std::random_device`                          | `time(0)`                          |
|-----------------------------|-----------------------------------------------|------------------------------------|
| **Randomness Quality**      | High (true randomness)                        | Low (predictable)                  |
| **Entropy Source**          | Hardware (e.g., CPU instructions, system noise)| System clock (seconds since epoch) |
| **Unpredictability**        | High (suitable for security-sensitive apps)   | Low (easy to guess)                |
| **Seed Range**              | Large (depends on implementation)             | Limited (32-bit or 64-bit integer) |
| **Portability**             | Works consistently across platforms           | Works everywhere but less reliable |
| **Performance**             | May be slower (depends on hardware)           | Very fast                          |


## Don't want to be hacked? //Todo

- [How randomized solutions can be hacked, and how to make your solution unhackable](https://codeforces.com/blog/entry/61675)
- [Blowing up unordered_map, and how to stop getting hacked on it](https://codeforces.com/blog/entry/62393)
- [On the mathematics behind rolling hashes and anti-hash tests](https://codeforces.com/blog/entry/60442)

```cpp
struct custom_hash { // Credits: https://codeforces.com/blog/entry/62393
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
    template<typename L, typename R>
    size_t operator()(pair<L,R> const& Y) const{
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(Y.first * 31ull + Y.second + FIXED_RANDOM);
    }
};
```
